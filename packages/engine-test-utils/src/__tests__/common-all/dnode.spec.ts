import {
  NoteUtils,
  SchemaUtils,
  DVault,
  SchemaOpts,
  NoteProps,
  VaultUtils,
} from "@dendronhq/common-all";
import sinon from "sinon";
import { NoteTestUtilsV4, TestNoteFactory } from "@dendronhq/common-test-utils";
import { runEngineTestV5 } from "../../engine";
import { ENGINE_HOOKS } from "../../presets";
import _ from "lodash";
import fs from "fs-extra";
import path from "path";

describe(`NoteUtils tests:`, () => {
  describe(`genSchemaDesc tests`, () => {
    const vault = { fsPath: "/tmp/ws/vault1" };
    const SCHEMA_ID = "id-1";

    async function testGenSchemaDesc(
      schemaCreateOpts: SchemaOpts & { vault: DVault },
      expectedDescription: string
    ) {
      const schema = SchemaUtils.createFromSchemaOpts(schemaCreateOpts);

      const wsRoot = "/tmp/ws/";
      const schemaModuleProps = await NoteTestUtilsV4.createSchema({
        fname: "/tmp/fname1",
        vault,
        wsRoot,
        noWrite: true,
      });
      schemaModuleProps.schemas[SCHEMA_ID] = schema;

      const note = await NoteTestUtilsV4.createNote({
        vault,
        wsRoot,
        noWrite: true,
        fname: "f1",
        props: {
          schema: {
            schemaId: schema.id,
            moduleId: "irrelevant",
          },
        },
      });

      const desc = NoteUtils.genSchemaDesc(note, schemaModuleProps);
      expect(desc).toEqual(expectedDescription);
    }

    it(`WHEN id is auto generated THEN use the pattern.`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          id: SCHEMA_ID,
          data: { pattern: "pattern-val", isIdAutoGenerated: true },
          vault,
        },
        "F1 $(repo) /tmp/fname1 $(breadcrumb-separator) pattern-val"
      );
    });

    it(`WHEN id is auto generated AND title is different than id then use title`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          title: "title-val",
          id: SCHEMA_ID,
          data: { pattern: "pattern-val", isIdAutoGenerated: true },
          vault,
        },
        "F1 $(repo) /tmp/fname1 $(breadcrumb-separator) title-val"
      );
    });

    it(`WHEN id is not auto generated AND title is equal to id THEN use title.`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          title: SCHEMA_ID,
          id: SCHEMA_ID,
          data: { pattern: "pattern-val" },
          vault,
        },
        `F1 $(repo) /tmp/fname1 $(breadcrumb-separator) ${SCHEMA_ID}`
      );
    });

    it(`WHEN id is not auto generated AND title is omitted THEN use id.`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          title: undefined,
          id: SCHEMA_ID,
          data: { pattern: "pattern-val" },
          vault,
        },
        `F1 $(repo) /tmp/fname1 $(breadcrumb-separator) ${SCHEMA_ID}`
      );
    });
  });
});

describe(`SchemaUtil tests:`, () => {
  describe(`WHEN running applyTemplate tests`, () => {
    const noteFactory: TestNoteFactory =
      TestNoteFactory.defaultUnitTestFactory();
    let note: NoteProps;
    const currentDate = new Date(2022, 0, 10);
    let clock: sinon.SinonFakeTimers;

    describe(`GIVEN current note's body is empty`, () => {
      beforeEach(async () => {
        note = await noteFactory.createForFName("new note");
        clock = sinon.useFakeTimers(currentDate);
      });
      afterEach(() => {
        sinon.restore();
        clock.restore();
      });

      it("WHEN applying a template, THEN replace note's body with template's body", async () => {
        await runEngineTestV5(
          async ({ engine }) => {
            const templateNote: NoteProps = engine.notes["foo"];
            const resp = SchemaUtils.applyTemplate({
              templateNote,
              note,
              engine,
            });
            expect(resp).toBeTruthy();
            expect(note.body).toEqual(engine.notes["foo"].body);
          },
          {
            expect,
            preSetupHook: ENGINE_HOOKS.setupSchemaPreseet,
          }
        );
      });

      it("WHEN applying a template with date variables, THEN replace note's body with template's body and with proper date substitution", async () => {
        await runEngineTestV5(
          async ({ engine }) => {
            const dateTemplate: NoteProps = engine.notes["date-variables"];
            const resp = SchemaUtils.applyTemplate({
              templateNote: dateTemplate,
              note,
              engine,
            });

            expect(resp).toBeTruthy();
            expect(note.body).not.toEqual(engine.notes["date-variables"].body);
            expect(note.body.trim()).toEqual(
              `Today is 2022.01.10` +
                "\n" +
                `This link goes to [[daily.journal.2022.01.10]]` +
                "\n" +
                `{{ 1 + 1 }} should not be evalated to 2`
            );
          },
          {
            expect,
            preSetupHook: ENGINE_HOOKS.setupRefs,
          }
        );
      });

      it("WHEN applying a template with fm variables, THEN replace note's body with template's body without errors", async () => {
        await runEngineTestV5(
          async ({ engine }) => {
            const fmTemplate: NoteProps = engine.notes["fm-variables"];
            const resp = SchemaUtils.applyTemplate({
              templateNote: fmTemplate,
              note,
              engine,
            });

            expect(resp).toBeTruthy();
            expect(note.body).toEqual(engine.notes["fm-variables"].body);
            expect(note.body.trim()).toEqual(`Title is {{ fm.title }}`);
          },
          {
            expect,
            preSetupHook: ENGINE_HOOKS.setupRefs,
          }
        );
      });
    });

    describe(`GIVEN current note's body is not empty`, () => {
      const noteBody = "test test";

      beforeEach(async () => {
        note = await noteFactory.createForFName("new note");
        note.body = noteBody;
      });

      it("WHEN applying a template, THEN append note's body with a \\n + template's body", async () => {
        await runEngineTestV5(
          async ({ engine }) => {
            const templateNote: NoteProps = engine.notes["foo"];
            const resp = SchemaUtils.applyTemplate({
              templateNote,
              note,
              engine,
            });
            expect(resp).toBeTruthy();
            expect(note.body).toEqual(
              noteBody + "\n" + engine.notes["foo"].body
            );
          },
          {
            expect,
            preSetupHook: ENGINE_HOOKS.setupSchemaPreseet,
          }
        );
      });
    });

    describe("GIVEN template type is not a note", () => {
      beforeEach(async () => {
        note = await noteFactory.createForFName("new note");
      });

      it("WHEN applying a template, THEN do nothing and return false ", async () => {
        await runEngineTestV5(
          async ({ engine }) => {
            const templateNote: NoteProps = engine.notes["foo"];
            templateNote.type = "schema";
            const resp = SchemaUtils.applyTemplate({
              templateNote,
              note,
              engine,
            });
            expect(resp).toBeFalsy();
          },
          {
            expect,
            preSetupHook: ENGINE_HOOKS.setupSchemaPreseet,
          }
        );
      });
    });
  });

  describe("Schema match tests", () => {
    testSchemaMatches({
      name: "GIVEN schema anatomy example from the wiki",
      schema: `version: 1
schemas:
# this will match "cli.*" notes
- id: cli 
  # human readable description of hierarchy
  desc: command line interface reference
  # add this to the domain of your schema hierarchy
  parent: root
  # when a schema is a namespace, it can have arbitrary children. equivalent to cli.* glob pattern
  namespace: true 
  children:
    - cmd
    - env
# will match cli.*.env
- id: env
  desc: cli specific env variables
# will match cli.*.cmd.*
- id: cmd
  desc: subcommands 
  namespace: true`,
      checks: {
        "cli.fd": "cli",
        "cli.fd.bar.usage": false,
        "cli.fd.cmd.usage": "cmd",
        "cli.fd.env": "env",
        "foo.bar": false,
      },
    });

    testSchemaMatches({
      name: "GIVEN inline schema anatomy example from the wiki",
      schema: `version: 1
schemas:
  # Daily is the top most schema since its parent is 'root' it must have an identifier
  # this identifier 'daily' will be used when using 'Lookup (schema)' command.
  - id: daily
    parent: root
    # Children of the top most schema do not need to contain identifier and just 
    # require a 'pattern' to be set to match the hierarchy of notes.
    children:
      - pattern: journal
        children:
          - pattern: "[0-2][0-9][0-9][0-9]"
            children:
              - pattern: "[0-1][0-9]"
                children:
                  - pattern: "[0-3][0-9]"
                    # As with regular schema we can set the template to be used with
                    # the match of our notes. Below is an example usage of shorthand template
                    # definition (which defaults to type: note). 
                    template: templates.daily`,
      checks: {
        "daily.journal.2021.10.24": true,
        "journal.2021.10.24": false,
        "daily.journal.5000.10.24": false,
        "daily.journal.2021.10.foo": false,
        "daily.journal.2021.10.24.foo": false,
      },
    });

    testSchemaMatches({
      name: "GIVEN daily journal pattern from the wiki",
      schema: `version: 1
schemas:
- id: journal
  title: journal
  desc: ""
  parent: root
  children:
    - year
- id: year
  title: year
  pattern: "[0-2][0-9][0-9][0-9]"
  children: 
    - month
- id: month
  title: month
  pattern: "[0-9][0-9]"
  children: 
    - day
- id: day
  title: day
  pattern: "[0-9][0-9]"
  namespace: true
`,
      checks: {
        journal: "journal",
        "journal.2020": "year",
        "journal.2020.09": "month",
        "journal.2020.09.12": "day",
        "journal.2020.09.12.foo": true,
        "daily.journal.2021.10.24": false,
        "journal.5000.10.24": false,
        "journal.2021.10.foo": false,
      },
    });

    testSchemaMatches({
      name: "GIVEN negated pattern in the middle",
      schema: `version: 1
schemas:
- id: projects
  parent: root
  children:
    - name
- id: name
  pattern: "!(scratch)"`,
      checks: {
        "projects.web-app": "name",
        "web-app": false,
        "projects.scratch": false,
      },
    });

    testSchemaMatches({
      name: "GIVEN dendron-docs RFC schema",
      schema: `version: 1
schemas:
  - id: rfc
    title: RFC
    parent: root
    children:
      - pattern: "+([0-9])-+([!])" # starts with 1 or more digits, a dash, then one or more characters
        template: dendron://dendron.docs/templates.rfc`,
      checks: {
        "rfc.41-test": true,
        "rfc.41": false,
        "rfc.test": false,
        "rfc.41-": false,
        "rfc.-test": false,
        "rfc.123123-foo-bar-baz": true,
      },
    });
  });
});

/** Tests if given fnames should match the schema.
 *
 * How to use this:
 * - Give a name for the group of tests. This should look like "GIVEN journal
 *   schema"
 * - Write the schema to be tested. This is the contents of a schema file that
 *   you would normally write.
 * - Write the checks. The checks are a map: the keys are note fnames, and the
 *   values are whether the schema should match this fname or not. If the value
 *   is a boolean, it will just check if it matches or not. You can also use a
 *   string for the value to check which schema id matches this fname.
 */
function testSchemaMatches({
  name,
  schema,
  checks,
}: {
  name: string;
  schema: string;
  checks: { [name: string]: string | boolean };
}) {
  describe(name, () => {
    for (const [notePath, expected] of Object.entries(checks)) {
      let testOutcome: string;
      if (!expected) testOutcome = "NOT match";
      else if (_.isString(expected)) testOutcome = `match ${expected}`;
      else testOutcome = "match";
      test(`THEN ${notePath} should ${testOutcome}`, async () => {
        await runEngineTestV5(
          async ({ engine }) => {
            debugger;
            const { schema } =
              SchemaUtils.matchPath({
                notePath,
                schemaModDict: engine.schemas,
              }) || {};
            if (!expected) {
              expect(schema).toBeUndefined();
            } else if (_.isString(expected)) {
              expect(schema?.id).toEqual(expected);
            } else {
              expect(schema).toBeTruthy();
            }
          },
          {
            expect,
            preSetupHook: async ({ wsRoot, vaults }) => {
              const schemaPath = path.join(
                wsRoot,
                VaultUtils.getRelPath(vaults[0]),
                "root.schema.yml"
              );
              await fs.writeFile(schemaPath, schema);
            },
          }
        );
      });
    }
  });
}
