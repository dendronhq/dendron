import YAML, { JSON_SCHEMA } from "js-yaml";
import _ from "lodash";
import minimatch from "minimatch";
import path from "path";
import { URI } from "vscode-uri";
import { ERROR_STATUS } from "../constants";
import { DNodeUtils, NoteUtils } from "../dnode";
import { DendronError } from "../error";
import {
  DEngineClient,
  DNodePropsQuickInputV2,
  DVault,
  NoteProps,
  NotePropsByIdDict,
  SchemaData,
  SchemaModuleOpts,
  SchemaModuleProps,
  SchemaOpts,
  SchemaProps,
  SchemaPropsDict,
  SchemaRaw,
} from "../types";

type SchemaMatchResult = {
  schemaModule: SchemaModuleProps;
  schema: SchemaProps;
  namespace: boolean;
  notePath: string;
};

export class SchemaUtils {
  static createFromSchemaRaw(opts: SchemaRaw & { vault: DVault }): SchemaProps {
    const schemaDataOpts: (keyof SchemaData)[] = [
      "namespace",
      "pattern",
      "template",
    ];
    const optsWithoutData = _.omit(opts, schemaDataOpts);
    const optsData = _.pick(opts, schemaDataOpts);

    this.processUntypedTemplate(optsData);

    const node = DNodeUtils.create({
      ..._.defaults(optsWithoutData, {
        title: optsWithoutData.id,
        data: optsData,
        fname: "__empty",
      }),
      type: "schema",
    });

    if (opts.isIdAutoGenerated) {
      node.data.isIdAutoGenerated = true;
    }

    return node;
  }

  static createFromSchemaOpts(
    opts: SchemaOpts & { vault: DVault }
  ): SchemaProps {
    const schemaDataOpts: (keyof SchemaData)[] = [
      "namespace",
      "pattern",
      "template",
    ];
    const optsWithoutData = _.omit(opts, schemaDataOpts);
    const optsData = _.pick(opts, schemaDataOpts);

    this.processUntypedTemplate(optsData);

    const vault = opts.vault;
    const node = DNodeUtils.create({
      vault,
      ..._.defaults(optsWithoutData, {
        title: optsWithoutData.id,
        data: optsData,
        fname: "__empty",
      }),
      type: "schema",
    });

    if (opts.data?.isIdAutoGenerated) {
      node.data.isIdAutoGenerated = true;
    }

    return node;
  }

  private static processUntypedTemplate(optsData: any) {
    // Standard templates have the format of
    //  `template: {id:'', type:''}`
    //
    // However we also want to support shorthand for declaring templates when just
    // the id of the template is specified with the format of
    //  `template: ''`
    if (_.isString(optsData.template)) {
      const typedTemplate = {
        id: optsData.template,
        type: "note",
      };

      optsData.template = typedTemplate;
    }
  }

  static createModule(opts: SchemaModuleOpts): SchemaModuleOpts {
    return opts;
  }

  static createModuleProps(opts: {
    fname: string;
    vault: DVault;
  }): SchemaModuleProps {
    const { fname, vault } = opts;
    const root = SchemaUtils.createFromSchemaOpts({
      id: `${fname}`,
      fname,
      parent: "root",
      created: 1,
      updated: 1,
      children: [],
      vault,
    });
    return {
      version: 1,
      fname,
      root,
      schemas: { [root.id]: root },
      imports: [],
      vault,
    };
  }

  static createRootModule(
    opts: Partial<SchemaProps> & { vault: DVault }
  ): SchemaModuleOpts {
    const schema = SchemaUtils.createFromSchemaOpts({
      id: "root",
      title: "root",
      fname: "root.schema",
      parent: "root",
      children: [],
      ...opts,
    });
    return {
      version: 1,
      imports: [],
      schemas: [schema],
    };
  }

  static createRootModuleProps(
    fname: string,
    vault: DVault,
    opts?: Partial<SchemaProps>
  ): SchemaModuleProps {
    const schema = SchemaUtils.createFromSchemaOpts({
      id: "root",
      title: "root",
      fname: "root",
      parent: "root",
      children: [],
      vault,
      ...opts,
    });
    return {
      version: 1,
      imports: [],
      schemas: { root: schema },
      fname,
      root: schema,
      vault,
    };
  }

  static enhanceForQuickInput({
    props,
    vaults,
  }: {
    props: SchemaModuleProps;
    vaults: DVault[];
  }): DNodePropsQuickInputV2 {
    const vaultSuffix =
      vaults.length > 1
        ? ` (${path.basename(props.vault?.fsPath as string)})`
        : "";
    const label = DNodeUtils.isRoot(props.root) ? "root" : props.root.id;
    const detail = props.root.desc;
    const out = {
      ...props.root,
      fname: props.fname,
      label,
      detail,
      description: vaultSuffix,
      vault: props.vault,
    };
    return out;
  }

  static getModuleRoot(
    module: SchemaModuleOpts | SchemaModuleProps
  ): SchemaProps {
    const maybeRoot = _.find(module.schemas, { parent: "root" });
    if (!maybeRoot) {
      const rootSchemaRoot = _.find(module.schemas, {
        parent: null,
        id: "root",
      });
      if (!rootSchemaRoot) {
        throw DendronError.createFromStatus({
          status: ERROR_STATUS.NO_ROOT_SCHEMA_FOUND,
        });
      } else {
        return rootSchemaRoot as SchemaProps;
      }
    }
    return maybeRoot as SchemaProps;
  }

  /**
   * If no pattern field, get the id.
   * If pattern field, check if namespace and translate into glob pattern
   * @param schema
   * @param opts
   * @returns
   */
  static getPattern = (
    schema: SchemaProps,
    opts?: { isNotNamespace?: boolean }
  ) => {
    const pattern = schema?.data?.pattern || schema.id;
    const part =
      schema?.data?.namespace && !opts?.isNotNamespace
        ? `${pattern}/*`
        : pattern;
    return part;
  };

  /**
   * Get full pattern starting from the root
   * @param schema
   * @param schemas
   * @returns
   */
  static getPatternRecursive = (
    schema: SchemaProps,
    schemas: SchemaPropsDict
  ): string => {
    const part = SchemaUtils.getPattern(schema);
    if (_.isNull(schema.parent)) {
      return part;
    }
    const parent: SchemaProps = schemas[schema.parent];
    if (parent && parent.id !== "root") {
      const prefix = SchemaUtils.getPatternRecursive(parent, schemas);
      return [prefix, part].join("/");
    } else {
      return part;
    }
  };

  /**
   * @param param0
   * @returns
   */
  static getPath({ root, fname }: { root: string; fname: string }): string {
    return path.join(root, fname + ".schema.yml");
  }

  static async doesSchemaExist({
    id,
    engine,
  }: {
    id: string;
    engine: DEngineClient;
  }) {
    return !_.isUndefined(await engine.getSchema(id));
  }

  static async getSchemaFromNote({
    note,
    engine,
  }: {
    note: NoteProps;
    engine: DEngineClient;
  }) {
    if (note.schema) {
      return (await engine.getSchema(note.schema.moduleId)).data;
    }
    return;
  }

  static hasSimplePattern = (
    schema: SchemaProps,
    opts?: { isNotNamespace?: boolean }
  ): boolean => {
    const pattern: string = SchemaUtils.getPattern(schema, opts);
    return !_.isNull(pattern.match(/^[a-zA-Z0-9_-]*$/));
  };

  /**
   * Match and assign schemas to all nodes within
   * a domain
   *
   * @param domain
   * @param notes
   * @param schemas
   */
  static async matchDomain(
    domain: NoteProps,
    notes: NotePropsByIdDict,
    engine: DEngineClient
  ) {
    const match = await engine.getSchema(domain.fname);
    if (!match.data) {
      return;
    } else {
      const domainSchema = match.data.schemas[match.data.root.id];
      return SchemaUtils.matchDomainWithSchema({
        noteCandidates: [domain],
        notes,
        schemaCandidates: [domainSchema],
        schemaModule: match.data,
      });
    }
  }

  static matchDomainWithSchema(opts: {
    noteCandidates: NoteProps[];
    notes: NotePropsByIdDict;
    schemaCandidates: SchemaProps[];
    schemaModule: SchemaModuleProps;
    matchNamespace?: boolean;
  }) {
    const {
      noteCandidates,
      schemaCandidates,
      notes,
      schemaModule,
      matchNamespace,
    } = _.defaults(opts, { matchNamespace: true });
    const matches = _.map(noteCandidates, (note) => {
      return SchemaUtils.matchNotePathWithSchemaAtLevel({
        notePath: note.fname,
        schemas: schemaCandidates,
        schemaModule,
        matchNamespace,
      });
    }).filter((ent) => !_.isUndefined(ent)) as SchemaMatchResult[];

    matches.map((m) => {
      const { schema, notePath } = m;
      const note = _.find(noteCandidates, { fname: notePath }) as NoteProps;
      NoteUtils.addSchema({ note, schema, schemaModule });

      const matchNextNamespace = !(schema.data.namespace && matchNamespace);
      const nextSchemaCandidates = matchNextNamespace
        ? schema.children.map((id) => schemaModule.schemas[id])
        : [schema];

      const nextNoteCandidates = note.children.map((id) => notes[id]);
      return SchemaUtils.matchDomainWithSchema({
        noteCandidates: nextNoteCandidates,
        schemaCandidates: nextSchemaCandidates,
        notes,
        schemaModule,
        matchNamespace: matchNextNamespace,
      });
    });
  }

  //  ^dtaatxvjb4s3
  static async matchPath(opts: {
    notePath: string;
    engine: DEngineClient; //
  }): Promise<SchemaMatchResult | undefined> {
    const { notePath } = opts;
    const domainName = DNodeUtils.domainName(notePath);
    const resp = await opts.engine.getSchema(domainName);
    if (!resp.data) {
      return;
    } else {
      const domainSchema = resp.data.schemas[resp.data.root.id];
      if (domainName.length === notePath.length) {
        return {
          schema: domainSchema,
          notePath,
          namespace: domainSchema.data.namespace || false,
          schemaModule: resp.data,
        };
      }
      return SchemaUtils.matchPathWithSchema({
        notePath,
        matched: "",
        schemaCandidates: [domainSchema],
        schemaModule: resp.data,
      });
    }
  }

  /**
   * Find proper schema from schema module that can be applied to note
   */
  static findSchemaFromModule(opts: {
    notePath: string;
    schemaModule: SchemaModuleProps;
  }): SchemaMatchResult | undefined {
    const { notePath, schemaModule } = opts;
    const domainName = DNodeUtils.domainName(notePath);
    const domainSchema = schemaModule.schemas[schemaModule.root.id];
    if (domainName.length === notePath.length) {
      return {
        schema: domainSchema,
        notePath,
        namespace: domainSchema.data.namespace || false,
        schemaModule,
      };
    }
    return SchemaUtils.matchPathWithSchema({
      notePath,
      matched: "",
      schemaCandidates: [domainSchema],
      schemaModule,
    });
  }

  /**
   *
   * @param param0
   * @return
   *  - schemaModule
   *  - schema
   *  - namespace
   *  - notePath
   */
  static matchPathWithSchema({
    notePath,
    matched,
    schemaCandidates,
    schemaModule,
    matchNamespace = true,
  }: {
    notePath: string;
    matched: string;
    schemaCandidates: SchemaProps[];
    schemaModule: SchemaModuleProps;
    matchNamespace?: boolean;
  }): SchemaMatchResult | undefined {
    const getChildOfPath = (notePath: string, matched: string) => {
      const nextLvlIndex = _.indexOf(notePath, ".", matched.length + 1);
      return nextLvlIndex > 0 ? notePath.slice(0, nextLvlIndex) : notePath;
    };

    const nextNotePath = getChildOfPath(notePath, matched);
    const match = SchemaUtils.matchNotePathWithSchemaAtLevel({
      notePath: nextNotePath,
      schemas: schemaCandidates,
      schemaModule,
      matchNamespace,
    });
    if (match) {
      const { schema, namespace } = match;
      // found a match
      if (notePath === nextNotePath) {
        return {
          schemaModule,
          schema,
          namespace,
          notePath,
        };
      }

      // if current note is a namespace and we are currently matching namespaces, don't match on the next turn
      const matchNextNamespace = !(schema.data.namespace && matchNamespace);

      // if we are not matching the next namespace, then we go back to regular matching behavior
      const nextSchemaCandidates = matchNextNamespace
        ? schema.children.map((id) => schemaModule.schemas[id])
        : [schema];
      return SchemaUtils.matchPathWithSchema({
        notePath,
        matched: nextNotePath,
        schemaCandidates: nextSchemaCandidates,
        schemaModule,
        matchNamespace: matchNextNamespace,
      });
    }
    return;
  }

  static matchNotePathWithSchemaAtLevel({
    notePath,
    schemas,
    schemaModule,
    matchNamespace = true,
  }: {
    notePath: string;
    schemas: SchemaProps[];
    schemaModule: SchemaModuleProps;
    matchNamespace?: boolean;
  }): SchemaMatchResult | undefined {
    const notePathClean = notePath.replace(/\./g, "/");
    let namespace = false;
    const match = _.find(schemas, (sc) => {
      const pattern = SchemaUtils.getPatternRecursive(sc, schemaModule.schemas);
      if (sc?.data?.namespace && matchNamespace) {
        namespace = true;
        // current note is at the level of the namespace node.
        // the glob pattern accounts for its immediate children (/*/*),
        // so in order to match the current note, we should slice off
        // the last bit of the glob pattern (/*)
        return minimatch(notePathClean, pattern.slice(0, -2));
      } else {
        // we are either trying to match the immediate child of a namespace node,
        // or match a non-namespace regular schema. use the pattern as-is
        return minimatch(notePathClean, pattern);
      }
    });
    if (match) {
      return {
        schema: match,
        namespace,
        notePath,
        schemaModule,
      };
    }
    return;
  }

  static serializeSchemaProps(props: SchemaProps | SchemaOpts): SchemaRaw {
    const builtinProps: Omit<SchemaOpts, "fname" | "vault"> = _.pick(props, [
      "id",
      "children",
    ]);
    const optional: (keyof Omit<SchemaOpts, "fname" | "vault">)[] = [
      "title",
      "desc",
    ];
    _.forEach(optional, (opt) => {
      if (props[opt]) {
        builtinProps[opt] = props[opt];
      }
    });
    const dataProps = props.data;
    // special for root
    if (props?.parent === "root") {
      builtinProps.parent = "root";
    }
    return { ...builtinProps, ...dataProps };
  }

  static isSchemaUri(uri: URI) {
    return uri.fsPath.endsWith(".schema.yml");
  }

  static serializeModuleProps(moduleProps: SchemaModuleProps) {
    const { version, imports, schemas } = moduleProps;
    // TODO: filter out imported schemas
    const out: any = {
      version,
      imports: [],
      schemas: _.values(schemas).map((ent) =>
        SchemaUtils.serializeSchemaProps(ent)
      ),
    };
    if (imports) {
      out.imports = imports;
    }
    return YAML.dump(out, { schema: JSON_SCHEMA });
  }

  // /**
  //  *
  //  * @param noteOrPath
  //  * @param schemas
  //  * @param opts
  //  *   - matchNamespace: should match exact namespace note (in addition to wildcard), default: false
  //  *   - matchPrefix: allow prefix match, default: false
  //  */
  // static match(
  //   noteOrPath: NoteProps| string,
  //   schemas: SchemaModuleV2[],
  //   opts?: { matchNamespace?: boolean; matchPrefix?: boolean }
  // ): SchemaProps {
  //   const cleanOpts = _.defaults(opts, {
  //     matchNamespace: true,
  //     matchPrefix: false,
  //   });
  //   const notePath = _.isString(noteOrPath) ? noteOrPath : noteOrPath.fname;
  //   const notePathClean = notePath.replace(/\./g, "/");
  //   let match: SchemaProps| undefined;
  //   _.find(schemas, (schemaMod) => {
  //     let schemasToMatch = schemaMod.schemas;
  //     return _.some(schemaDomain.nodes, (schema) => {
  //       const patternMatch = schema.patternMatch;
  //       if (
  //         (schema as SchemaProps).data.namespace &&
  //         cleanOpts.matchNamespace
  //       ) {
  //         if (minimatch(notePathClean, _.trimEnd(patternMatch, "/*"))) {
  //           match = schema;
  //           return true;
  //         }
  //       }
  //       if (minimatch(notePathClean, patternMatch)) {
  //         match = schema;
  //         return true;
  //       } else {
  //         return false;
  //       }
  //     });
  //   });
  //   if (_.isUndefined(match)) {
  //     throw Error("not implemented");
  //   }
  //   return match;
  // }
}
