import {
  NoteUtils,
  SchemaUtils,
  DVault,
  SchemaOpts,
} from "@dendronhq/common-all";
import { NoteTestUtilsV4, TestNoteFactory } from "@dendronhq/common-test-utils";
import { runEngineTestV5 } from "../../engine";
import { ENGINE_HOOKS } from "../../presets";

describe(`NoteUtils tests:`, () => {
  describe(`genSchemaDesc tests`, () => {
    const vault = { fsPath: "/tmp/ws/vault1" };
    const SCHEMA_ID = "id-1";

    async function testGenSchemaDesc(
      schemaCreateOpts: SchemaOpts & { vault: DVault },
      expectedDescription: string
    ) {
      const schema = SchemaUtils.createFromSchemaOpts(schemaCreateOpts);

      const wsRoot = "/tmp/ws/";
      const schemaModuleProps = await NoteTestUtilsV4.createSchema({
        fname: "/tmp/fname1",
        vault,
        wsRoot,
        noWrite: true,
      });
      schemaModuleProps.schemas[SCHEMA_ID] = schema;

      const note = await NoteTestUtilsV4.createNote({
        vault,
        wsRoot,
        noWrite: true,
        fname: "f1",
        props: {
          schema: {
            schemaId: schema.id,
            moduleId: "irrelevant",
          },
        },
      });

      const desc = NoteUtils.genSchemaDesc(note, schemaModuleProps);
      expect(desc).toEqual(expectedDescription);
    }

    it(`WHEN id is auto generated THEN use the pattern.`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          id: SCHEMA_ID,
          data: { pattern: "pattern-val", isIdAutoGenerated: true },
          vault,
        },
        "F1 $(repo) /tmp/fname1 $(breadcrumb-separator) pattern-val"
      );
    });

    it(`WHEN id is auto generated AND title is different than id then use title`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          title: "title-val",
          id: SCHEMA_ID,
          data: { pattern: "pattern-val", isIdAutoGenerated: true },
          vault,
        },
        "F1 $(repo) /tmp/fname1 $(breadcrumb-separator) title-val"
      );
    });

    it(`WHEN id is not auto generated AND title is equal to id THEN use title.`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          title: SCHEMA_ID,
          id: SCHEMA_ID,
          data: { pattern: "pattern-val" },
          vault,
        },
        `F1 $(repo) /tmp/fname1 $(breadcrumb-separator) ${SCHEMA_ID}`
      );
    });

    it(`WHEN id is not auto generated AND title is omitted THEN use id.`, async () => {
      await testGenSchemaDesc(
        {
          fname: "hi",
          title: undefined,
          id: SCHEMA_ID,
          data: { pattern: "pattern-val" },
          vault,
        },
        `F1 $(repo) /tmp/fname1 $(breadcrumb-separator) ${SCHEMA_ID}`
      );
    });
  });
});

describe(`SchemaUtil tests:`, () => {
  describe(`applyTemplate tests`, () => {
    test("Test that template note's body replaces empty note's body", async () => {
      await runEngineTestV5(
        async ({ engine }) => {
          const noteFactory = TestNoteFactory.defaultUnitTestFactory();
          const note = await noteFactory.createForFName("new note");

          const resp = SchemaUtils.applyTemplate({
            template: { id: "foo", type: "note" },
            note,
            engine,
          });
          expect(resp).toBeTruthy();
          expect(note.body).toEqual(engine.notes["foo"].body);
          return [];
        },
        {
          expect,
          preSetupHook: ENGINE_HOOKS.setupSchemaPreseet,
        }
      );
    });

    test("Test that template note's body is appended to existing note's body", async () => {
      await runEngineTestV5(
        async ({ engine }) => {
          const noteFactory = TestNoteFactory.defaultUnitTestFactory();
          const note = await noteFactory.createForFName("new note");
          const noteBody = "test test";
          note.body = noteBody;

          const resp = SchemaUtils.applyTemplate({
            template: { id: "foo", type: "note" },
            note,
            engine,
          });
          expect(resp).toBeTruthy();
          expect(note.body).toEqual(noteBody + "\n" + engine.notes["foo"].body);
          return [];
        },
        {
          expect,
          preSetupHook: ENGINE_HOOKS.setupSchemaPreseet,
        }
      );
    });

    test("Test that applying template only applies to type note", async () => {
      await runEngineTestV5(
        async ({ engine }) => {
          const noteFactory = TestNoteFactory.defaultUnitTestFactory();
          const note = await noteFactory.createForFName("new note");

          const resp = SchemaUtils.applyTemplate({
            template: { id: "foo", type: "snippet" },
            note,
            engine,
          });
          expect(resp).toBeFalsy();
          return [];
        },
        {
          expect,
          preSetupHook: ENGINE_HOOKS.setupSchemaPreseet,
        }
      );
    });
  });
});
